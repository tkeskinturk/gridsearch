[{"path":"https://tkeskinturk.github.io/gridsearch/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Turgut Keskintürk Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/articles/usage.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Using the gridsearch Package","text":"Researchers working panel data often pose three core questions. Given observed survey trajectories individual responses empirical data, many people changed? much changed? changed within observed sample? often involves questions like whether people changed policy preferences within specific time-window, whether substantive portion respondents moved positions. said, longitudinal change result various mechanisms: large segments population may shift opinions specific direction small large amounts; small segment population may large changes; mix changes—including positive negative movements—may alter overall balance. gridsearch designed give researchers preliminary check potential data generation processes may generated observed data.","code":""},{"path":[]},{"path":"https://tkeskinturk.github.io/gridsearch/articles/usage.html","id":"data-generation-processes","dir":"Articles","previous_headings":"Illustration","what":"Data Generation Processes","title":"Using the gridsearch Package","text":"Think panel study, observe 1,000 individuals across 3 time periods. Let us generate one simulated dataframe, know true data generation process. generated data underlying data-generation process (DGP). noted 1,000 individuals (n) observed 3 times (t). individuals latent positions policy item, let’s call y_true, shows normal latent distribution:  also specified 50% 1,000 individuals (rate) changed underlying latent positions within window 1 SD (strength) positive direction (balance_dir). means , aggregate, change roughly 0.5 SD entire population: Another way look randomly pick individuals see patterns:  Yet, suppose survey team asked question binary terms, respondents two options, agree disagree, answer question. Suppose also question wording related problems, make reliability item 80% (reliable). means , three-wave period, multiple response patterns observed empirical data: can answer three questions initially posed?","code":"set.seed(1123)  d <- buildDGP(   n = 1000,   t = 3,   rate = 0.5,   balance_dir = 1,   balance_res = 0.5,   strength = 1,   reliable = 0.8,   export = TRUE,   patterns = TRUE,   slopes = TRUE ) ggplot(d$data, aes(x = y_true)) +   geom_histogram(bins = 30) +   theme_bw() +   labs(x = \"Latent Position\", y = \"\") lm(y_true ~ t, data = d$data) #>  #> Call: #> lm(formula = y_true ~ t, data = d$data) #>  #> Coefficients: #> (Intercept)            t   #>    -0.01765      0.47800 d$data |>   filter(pid %in% c(sample(1:1000, size = 9))) |>   ggplot(aes(x = factor(t), y = y_true, group = 1)) +   geom_line() +   facet_wrap( ~ pid) +   theme_bw() d$patterns #> # A tibble: 8 × 2 #>   patterns     n #>   <chr>    <int> #> 1 000        307 #> 2 001        122 #> 3 010         43 #> 4 011        124 #> 5 100         22 #> 6 101         45 #> 7 110         36 #> 8 111        301"},{"path":"https://tkeskinturk.github.io/gridsearch/articles/usage.html","id":"grid-search-algorithm","dir":"Articles","previous_headings":"Illustration","what":"Grid Search Algorithm","title":"Using the gridsearch Package","text":"grid-search algorithm tries answer question. performs three steps: generates grid 41 x 40 panels, 41 values representing percent units changing 0 1, 40 values representing strength change SD terms, ranging 0 2. generates 5 panels, panel specifies specific mix change trajectories: everyone changing negatively, 75% changing negatively 25% changing positively, 50% changing negatively 50% changing positively, 25% changing negatively 75% changing positively, everyone changing positively. cell, procedure generates NN simulated dataset, using parameter values DGP. simulated dataset, generates contingency table (presented ) calculates summed difference contingency table observed empirical table. example process: [0,0,00,0,10,1,00,1,11,0,01,0,11,1,01,1,1]=[Observed86915375115657154746]−[Simulated810751035718866148701]=[Absolute Difference5978285812359445] \\begin{bmatrix} \\\\ 0, 0, 0 \\\\ 0, 0, 1 \\\\ 0, 1, 0 \\\\ 0, 1, 1 \\\\ 1, 0, 0 \\\\ 1, 0, 1 \\\\ 1, 1, 0 \\\\ 1, 1, 1 \\end{bmatrix}  = \\begin{bmatrix} \\text{Observed} \\\\ 869 \\\\ 153 \\\\ 75 \\\\ 115 \\\\ 65 \\\\ 71 \\\\ 54 \\\\ 746 \\\\ \\end{bmatrix} - \\begin{bmatrix} \\text{Simulated} \\\\ 810 \\\\ 75 \\\\ 103 \\\\ 57 \\\\ 188 \\\\ 66 \\\\ 148 \\\\ 701 \\\\ \\end{bmatrix} = \\begin{bmatrix} \\text{Absolute Difference} \\\\ 59 \\\\ 78 \\\\ 28 \\\\ 58 \\\\ 123 \\\\ 5 \\\\ 94 \\\\ 45 \\\\ \\end{bmatrix} Finally, algorithm goes several smoothing stages. contingency table , absolute difference equals 490. represents one cell grids. algorithm smoothes cells leveraging information neighboring cells, cell averaged using 25 cells (24 neighbor cells ). estimates tensor product smooth fitting model interacts rate change strength change panel, allowing us general estimates close cell observed data generation process. Let’s apply simulated dataset. gridSearch function gives us tibble 8,200 rows 6 columns: rate represents 41 values % changing DGP, strength represents 40 values SD change, direction represents 5 conditions mixing positive negative changers, error predicted error score (distance simulated dataset observed dataset, smoothing procedures applied), pattern represents calculation method (see ), n shows unique number individuals empirical dataset.","code":"grid <- gridSearch(   data = d$data,   yname = 'y_obs', ## observed binary outcome   tname = 't', ## time variable   pname = 'pid', ## panel identifier   steps = 1, ## the number of simulated datasets per cell   reliability = 0.8, ## assumed reliability score   workers = 4 ) #> This function drops missing values. Tread carefully. #>  #>  We now start the calculations. There will be 3 steps. #>  #>  Step 1 for grid search... #>  #>  Step 2 for grid search... #>  #>  Step 3 for grid search...  print(grid) #> # A tibble: 8,200 × 6 #>     rate strength direction       error pattern         n #>    <dbl>    <dbl> <fct>           <dbl> <chr>       <int> #>  1     0     0.05 100% Down        286. contingency  1000 #>  2     0     0.05 75% Down-25% Up  292. contingency  1000 #>  3     0     0.05 50% Down-50% Up  286. contingency  1000 #>  4     0     0.05 25% Down-75% Up  284. contingency  1000 #>  5     0     0.05 100% Up          292. contingency  1000 #>  6     0     0.1  100% Down        286. contingency  1000 #>  7     0     0.1  75% Down-25% Up  292. contingency  1000 #>  8     0     0.1  50% Down-50% Up  286. contingency  1000 #>  9     0     0.1  25% Down-75% Up  285. contingency  1000 #> 10     0     0.1  100% Up          292. contingency  1000 #> # ℹ 8,190 more rows"},{"path":"https://tkeskinturk.github.io/gridsearch/articles/usage.html","id":"evaluating-the-potential-dgps","dir":"Articles","previous_headings":"Illustration","what":"Evaluating the Potential DGPs","title":"Using the gridsearch Package","text":"Let’s look error scores minimize distance: Remember initial dataframe featured 50% sample changing 1 SD positive direction. see smallest error terms close values. can visually see best terms using gridPlot:  plot shows best values approximate data 1%, 5% 10% quantiles.","code":"grid |> arrange(error) #> # A tibble: 8,200 × 6 #>     rate strength direction error pattern         n #>    <dbl>    <dbl> <fct>     <dbl> <chr>       <int> #>  1 0.525     1.05 100% Up    68.0 contingency  1000 #>  2 0.55      1.05 100% Up    68.7 contingency  1000 #>  3 0.55      1    100% Up    68.8 contingency  1000 #>  4 0.5       1.1  100% Up    69.2 contingency  1000 #>  5 0.525     1.1  100% Up    69.3 contingency  1000 #>  6 0.5       1.05 100% Up    69.4 contingency  1000 #>  7 0.525     1    100% Up    69.5 contingency  1000 #>  8 0.575     1    100% Up    69.8 contingency  1000 #>  9 0.575     1.05 100% Up    71.3 contingency  1000 #> 10 0.5       1.15 100% Up    71.3 contingency  1000 #> # ℹ 8,190 more rows gridPlot(grid)"},{"path":[]},{"path":"https://tkeskinturk.github.io/gridsearch/articles/usage.html","id":"an-alternative-comparison","dir":"Articles","previous_headings":"Extensions","what":"An Alternative Comparison","title":"Using the gridsearch Package","text":"plausible t sufficiently large, use contingency tables might problematic, may want impose constraints observed responses want take survey response seriously. gridSearch function pattern argument takes slopes instead patterns response. showed examples using contingency table approach , propose alternative, . approach, people can use slopes option, estimates logistic regressions individual level—effectively fitting varying individual fixed effects models—calculates model predicted difference units’ first response last response. gives us approximation much individuals changed time, average. slopes represented individual dataframe: procedure exactly , exception rather calculating summed differences across contingency tables, algorithm now calculates Kilmogorov-Smirnov statistic using observed distribution slopes simulated distribution slopes.","code":"d$slopes #> # A tibble: 1,000 × 2 #>      pid estimate #>    <int>    <dbl> #>  1     1        0 #>  2     2        0 #>  3     3        0 #>  4     4        0 #>  5     5        0 #>  6     6        1 #>  7     7       -1 #>  8     8        0 #>  9     9        1 #> 10    10        1 #> # ℹ 990 more rows"},{"path":"https://tkeskinturk.github.io/gridsearch/articles/usage.html","id":"the-detection-of-changers","dir":"Articles","previous_headings":"Extensions","what":"The Detection of Changers","title":"Using the gridsearch Package","text":"Suppose settled DGP—let’s say, 50% people changing 1 SD positive direction. much can confident pin specific individuals dataset? simulateChangers function allows us know answer question. procedure simple: feed DGP function—just like buildDGP function—generate NN simulated datasets, use varying slope procedure described , compare whether specific individual known changer simulation procedure can detected using individual fixed effects, conditional strength parameter specified . Let us see example. can seen, simulateChangers spits three values: sensitivity measure, ability identify true changers; specificity measure, ability identify true non-changers, kappa score, weighted summary two measures.","code":"sim <- simulateChangers(   n = 1000,   t = 3,   rate = 0.5,   balance_dir = 1,   balance_res = 0.5,   strength = 1,   reliable = 0.8,   nrep = 500,   workers = 4 )  print(sim) #> # A tibble: 500 × 4 #>     sims  kappa sensitivity specificity #>    <int>  <dbl>       <dbl>       <dbl> #>  1     1 0.113        0.321       0.792 #>  2     2 0.0547       0.282       0.771 #>  3     3 0.189        0.388       0.802 #>  4     4 0.147        0.355       0.792 #>  5     5 0.141        0.367       0.774 #>  6     6 0.154        0.370       0.785 #>  7     7 0.102        0.331       0.773 #>  8     8 0.128        0.330       0.793 #>  9     9 0.173        0.395       0.783 #> 10    10 0.174        0.400       0.775 #> # ℹ 490 more rows sim |>   summarize(     sensitivity_mean = mean(sensitivity),     specificity_mean = mean(specificity),   ) #> # A tibble: 1 × 2 #>   sensitivity_mean specificity_mean #>              <dbl>            <dbl> #> 1            0.356            0.784"},{"path":"https://tkeskinturk.github.io/gridsearch/articles/usage.html","id":"warnings-and-notes","dir":"Articles","previous_headings":"","what":"Warnings and Notes","title":"Using the gridsearch Package","text":"like flag issues need aware : Currently, gridsearch accomodates binary outcomes. hoping generalize procedures cases 2 response categories. slopes method gridSearch function may helpful longer panels, note computationally heavy calculates individual slopes individual. functions rely heavily parallelization, argument workers allows control number parallel workers functions use. strongly suggest calculations parallelized; otherwise wait times can long. details protocol, please see article, Promises Pitfalls Using Panel Data Understand Individual Belief Change, stored SocArXiv.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Turgut Keskintürk. Author, maintainer. Stephen Vaisey. Author.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Keskintürk T, Vaisey S (2024). gridsearch: Performs Grid Search Individual Change Panel Data. R package version 0.1.0, https://tkeskinturk.github.io/gridsearch/.","code":"@Manual{,   title = {gridsearch: Performs Grid Search for Individual Change in Panel Data},   author = {Turgut Keskintürk and Stephen Vaisey},   year = {2024},   note = {R package version 0.1.0},   url = {https://tkeskinturk.github.io/gridsearch/}, }"},{"path":"https://tkeskinturk.github.io/gridsearch/index.html","id":"gridsearch-","dir":"","previous_headings":"","what":"Performs Grid Search for Individual Change in Panel Data","title":"Performs Grid Search for Individual Change in Panel Data","text":"gridsearch R package used adjudicating plausible data generation processes (DGP) given panel dataset. current version, gridsearch allows researchers : Generate simulated datasets given set DGP parameters, Implement simple grid-search algorithm see plausible combinations parameter values may approximate observed marginal distributions, Plot distance values generated grid-search algorithm, Generate simple simulations calculating classification accuracy measures see whether, given DGP, can identify individual changers certain level accuracy. package companion article, Promises Pitfalls Using Panel Data Understand Individual Belief Change, stored SocArXiv.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Performs Grid Search for Individual Change in Panel Data","text":"can install development version gridsearch Github :","code":"# install.packages(\"devtools\") devtools::install_github(\"tkeskinturk/gridsearch\")"},{"path":"https://tkeskinturk.github.io/gridsearch/reference/buildDGP.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Panel Data from a DGP — buildDGP","title":"Build Panel Data from a DGP — buildDGP","text":"function (1) builds simulated dataset using parameters supplied function call, (2) generates distinct outcome patterns concatenating outcomes across time periods individual provides counts pattern, (3) calculates slope coefficients change individual level.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/buildDGP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Panel Data from a DGP — buildDGP","text":"","code":"buildDGP(   n = 1000,   t = 3,   rate = 0.25,   balance_dir = 0.5,   balance_res = 0.5,   strength = 1,   reliable = 0.8,   export = TRUE,   patterns = FALSE,   slopes = FALSE )"},{"path":"https://tkeskinturk.github.io/gridsearch/reference/buildDGP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Panel Data from a DGP — buildDGP","text":"n number units DGP. t number time periods. rate percent units changing across panel. balance_dir direction change, 0 codes negative change, 1 codes positive change, values -codes percentage changers changing positive direction. balance_res marginal distribution outcome (effectively regulating percent distribution 0s 1s). strength strength change latent variable. reliable reliability score outcome measurement. export export = TRUE, function exports simulated dataset. patterns patterns = TRUE, function exports concatenated panel patterns. slopes slopes = TRUE, function exports slope coefficients.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/buildDGP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Panel Data from a DGP — buildDGP","text":"dataframe list.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/buildDGP.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build Panel Data from a DGP — buildDGP","text":"Basic buildDGP() call:   Basic buildDGP() call patterns:","code":"set.seed(11235) data <- buildDGP(n = 2,                  t = 3,                  rate = 0.5,                  balance_dir = 1,                  balance_res = 0.5,                  strength = 1,                  reliable = 0.9,                  export = TRUE,                  patterns = FALSE,                  slopes = FALSE) print(data) #> # A tibble: 6 x 6 #>     pid changer timing     t y_true y_obs #>   <int>   <int>  <dbl> <dbl>  <dbl> <dbl> #> 1     1       0    0     0   -0.297     1 #> 2     1       0    0     0.5 -0.297     0 #> 3     1       0    0     1   -0.297     1 #> 4     2       1    0.5   0   -1.42      0 #> 5     2       1    0.5   0.5 -0.424     1 #> 6     2       1    0.5   1   -0.424     0 set.seed(11235) data <- buildDGP(n = 100,                  t = 3,                  rate = 0.5,                  balance_dir = 0.5,                  balance_res = 0.5,                  strength = 1,                  reliable = 0.9,                  export = TRUE,                  patterns = TRUE,                  slopes = FALSE) print(data) #> $data #> # A tibble: 300 x 6 #>      pid changer timing     t   y_true y_obs #>    <int>   <int>  <dbl> <dbl>    <dbl> <dbl> #>  1     1       1    0.5   0   -0.297       0 #>  2     1       1    0.5   0.5 -1.30        0 #>  3     1       1    0.5   1   -1.30        0 #>  4     2       0    0     0   -1.42        0 #>  5     2       0    0     0.5 -1.42        0 #>  6     2       0    0     1   -1.42        0 #>  7     3       0    0     0   -0.216       0 #>  8     3       0    0     0.5 -0.216       0 #>  9     3       0    0     1   -0.216       0 #> 10     4       0    0     0   -0.00588     0 #> # i 290 more rows #> #> $patterns #> # A tibble: 8 x 2 #>   patterns     n #>   <chr>    <int> #> 1 000         35 #> 2 001          6 #> 3 010          3 #> 4 011          2 #> 5 100          7 #> 6 101          5 #> 7 110          6 #> 8 111         36"},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot DGP Grids — gridPlot","title":"Plot DGP Grids — gridPlot","text":"function plots distribution error scores resulting gridSearch.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot DGP Grids — gridPlot","text":"","code":"gridPlot(data, cut1 = 0.05, cut2 = 0.1, cut3 = 0.2)"},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot DGP Grids — gridPlot","text":"data data frame generated gridSearch. cut1 Cut error values DGPs: Group 1. cut2 Cut error values DGPs: Group 2. cut3 Cut error values DGPs: Group 3.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot DGP Grids — gridPlot","text":"ggplot2 object.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridSearch.html","id":null,"dir":"Reference","previous_headings":"","what":"Grid Search for Adjudicating DGPs — gridSearch","title":"Grid Search for Adjudicating DGPs — gridSearch","text":"function uses three-step grid search algorithm calculate extent dataframe can approximated known DGP. implements fake-data simulations grid plausible values—rate change ranging 0% 100%, strength change ranging 0 SD 2 SD, 5 directional cases (everyone changing negatively, everyone changing positively, half changing negatively half changing positively, 25% changing negatively 75% changing positively, 75% changing negatively 25% changing positively), calculates distribution response patterns slopes, provides error term summarizes distance DGP observed values.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridSearch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grid Search for Adjudicating DGPs — gridSearch","text":"","code":"gridSearch(   data,   yname,   tname,   pname,   pattern = c(\"contingency\", \"slopes\"),   steps = 1,   reliability = 0.9,   seed = 11235,   workers = 8 )"},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridSearch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grid Search for Adjudicating DGPs — gridSearch","text":"data dataframe. yname outcome identifier. tname time identifier. pname unit identifier. pattern pattern = contingency, calculations based use contingency table panel patterns; pattern = slopes, function uses individual slope coefficients. steps number simulated datasets. reliability assumed reliability score outcome measurement. seed Seed reproducibility. workers number workers parallelization (note parallelization highly recommended reasonable duration).","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridSearch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grid Search for Adjudicating DGPs — gridSearch","text":"data frame.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/gridSearch.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grid Search for Adjudicating DGPs — gridSearch","text":"Basic gridSearch() call:","code":"set.seed(1871) data <- buildDGP(n = 50,                  t = 3,                  rate = 0.5,                  balance_dir = 1,                  balance_res = 0.5,                  strength = 1,                  reliable = 0.9,                  export = TRUE,                  patterns = FALSE,                  slopes = FALSE) gridSearch(data = data,            yname = 'y_obs',            tname = 't',            pname = 'pid',            pattern = 'contingency',            steps = 1,            reliability = 0.9,            seed = 11234,            workers = 10) #> This function drops missing values. Tread carefully. #> #>  We now start the calculations. There will be 3 steps. #> #>  Step 1 for grid search... #> #>  Step 2 for grid search... #> #>  Step 3 for grid search... #> # A tibble: 8,200 x 6 #>     rate strength direction       error pattern         n #>    <dbl>    <dbl> <fct>           <dbl> <chr>       <int> #>  1     0     0.05 100% Down        23.0 contingency    50 #>  2     0     0.05 75% Down-25% Up  23.8 contingency    50 #>  3     0     0.05 50% Down-50% Up  22.7 contingency    50 #>  4     0     0.05 25% Down-75% Up  24.0 contingency    50 #>  5     0     0.05 100% Up          24.4 contingency    50 #>  6     0     0.1  100% Down        23.1 contingency    50 #>  7     0     0.1  75% Down-25% Up  23.9 contingency    50 #>  8     0     0.1  50% Down-50% Up  22.8 contingency    50 #>  9     0     0.1  25% Down-75% Up  23.8 contingency    50 #> 10     0     0.1  100% Up          24.2 contingency    50 #> # i 8,190 more rows"},{"path":"https://tkeskinturk.github.io/gridsearch/reference/simulateChangers.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Changers and Calculate Accuracy — simulateChangers","title":"Simulate Changers and Calculate Accuracy — simulateChangers","text":"function uses parameter values given DGP calculate kappa, sensitivity, specificity scores simulated data frames.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/simulateChangers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Changers and Calculate Accuracy — simulateChangers","text":"","code":"simulateChangers(   n = 1000,   t = 3,   rate = 0.25,   balance_dir = 0.5,   balance_res = 0.5,   strength = 1,   reliable = 0.8,   nrep = 1000,   seed = 11235,   workers = 8 )"},{"path":"https://tkeskinturk.github.io/gridsearch/reference/simulateChangers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Changers and Calculate Accuracy — simulateChangers","text":"n number units DGP. t number time periods. rate percent units changing across panel. balance_dir direction change, 0 codes negative change, 1 codes positive change, values -codes percentage changers changing positive direction. balance_res marginal distribution outcome (effectively regulating percent distribution 0s 1s). strength strength change latent variable. reliable reliability score outcome measurement. nrep number simulation runs. seed Seed reproducibility. workers number workers parallelization (note parallelization highly recommended reasonable duration).","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/simulateChangers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Changers and Calculate Accuracy — simulateChangers","text":"data frame.","code":""},{"path":"https://tkeskinturk.github.io/gridsearch/reference/simulateChangers.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Changers and Calculate Accuracy — simulateChangers","text":"Basic simulateChangers() call:","code":"set.seed(11235) data <- simulateChangers(n = 100,                          t = 3,                          rate = 0.5,                          balance_dir = 1,                          balance_res = 0.5,                          strength = 1,                          reliable = 0.9,                          nrep = 100,                          seed = 11234,                          workers = 10) print(data) #> # A tibble: 100 x 4 #>     sims kappa sensitivity specificity #>    <int> <dbl>       <dbl>       <dbl> #>  1     1 0.340       0.432       0.893 #>  2     2 0.119       0.278       0.848 #>  3     3 0.117       0.229       0.885 #>  4     4 0.236       0.362       0.868 #>  5     5 0.370       0.481       0.896 #>  6     6 0.319       0.404       0.906 #>  7     7 0.26        0.38        0.88 #>  8     8 0.266       0.345       0.952 #>  9     9 0.376       0.545       0.844 #> 10    10 0.120       0.26        0.86 #> # i 90 more rows"}]
